# Game Engine Project - PalBomb

‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡πÄ‡∏Å‡∏° Bomber-Style Top-Down Map ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ OpenGL ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏ö‡∏ö 3D ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏ö‡∏ö texture mapping

## üìã ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ

‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Å‡∏° Bomber-Style Top-Down Map ‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏ô‡∏≤‡∏î 15x15 tiles ‡πÇ‡∏î‡∏¢‡∏°‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏Ç‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡πÑ‡∏î‡πâ‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö Perspective Camera ‡πÅ‡∏ö‡∏ö top-down view

## ‚ú® ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥

- **3D Tile Rendering**: ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏ö‡∏ö 3D ‡∏î‡πâ‡∏ß‡∏¢ tiles
- **Texture Mapping**: ‡πÉ‡∏ä‡πâ texture ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏Ç‡∏≠‡∏ö
- **Top-Down Camera**: ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏°‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô
- **Border System**: ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡∏≠‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏û‡∏∑‡πâ‡∏ô
- **Dynamic Rendering**: ‡πÄ‡∏£‡∏ô‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏∏‡∏Å frame ‡∏î‡πâ‡∏ß‡∏¢ render loop

## üéÆ ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°

- **ESC**: ‡∏õ‡∏¥‡∏î‡πÄ‡∏Å‡∏°

## üõ†Ô∏è ‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ

- **OpenGL 3.3**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏ô‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Å‡∏£‡∏≤‡∏ü‡∏¥‡∏Å 3D
- **GLFW**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÅ‡∏•‡∏∞ input
- **GLAD**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö OpenGL function loader
- **GLM**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ó‡∏≤‡∏á‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå (vectors, matrices)
- **STB Image**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå texture (PNG)
- **CMake**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö build system

## üìÅ ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ

```
GameEngProject-Palbom/
‚îú‚îÄ‚îÄ assets/              # ‡πÑ‡∏ü‡∏•‡πå texture
‚îÇ   ‚îú‚îÄ‚îÄ floor/          # Texture ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô
‚îÇ   ‚îî‚îÄ‚îÄ Unbreakable_Block/  # Texture ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡∏≠‡∏ö
‚îú‚îÄ‚îÄ shaders/            # Shader files
‚îÇ   ‚îú‚îÄ‚îÄ tile.vs        # Vertex shader
‚îÇ   ‚îî‚îÄ‚îÄ tile.fs        # Fragment shader
‚îú‚îÄ‚îÄ src/                # Source code
‚îÇ   ‚îî‚îÄ‚îÄ main.cpp       # Main game loop
‚îî‚îÄ‚îÄ CMakeLists.txt     # CMake configuration
```

## üöÄ ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ô

### ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö

- CMake 3.16 ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤
- C++17 compiler
- OpenGL 3.3 ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤

### ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£ Build

1. **Clone ‡∏´‡∏£‡∏∑‡∏≠‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ**

2. **‡∏™‡∏£‡πâ‡∏≤‡∏á build directory ‡πÅ‡∏•‡∏∞ build ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ**:
```bash
cmake -S . -B build
cmake --build build
```

3. **‡∏£‡∏±‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°**:
```bash
cd build
./PlayableCharacter
```

### ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Windows

```bash
cmake -S . -B build
cmake --build build --config Release
cd build/Release
PlayableCharacter.exe
```

## üíª ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÇ‡∏Ñ‡πâ‡∏î (Code Explanation)

### üìÑ main.cpp - ‡πÇ‡∏Ñ‡πâ‡∏î‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 1: Includes ‡πÅ‡∏•‡∏∞ Headers

```cpp
#include <glad/glad.h>      // ‡πÇ‡∏´‡∏•‡∏î OpenGL functions
#include <GLFW/glfw3.h>     // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÅ‡∏•‡∏∞ input
#include <stb_image.h>      // ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û (texture)
#include <glm/glm.hpp>      // Math library ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö vectors ‡πÅ‡∏•‡∏∞ matrices
#include <learnopengl/shader_m.h>  // Shader class ‡∏à‡∏≤‡∏Å LearnOpenGL
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **glad/glad.h**: ‡πÇ‡∏´‡∏•‡∏î OpenGL function pointers ‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ OpenGL API
- **GLFW/glfw3.h**: Library ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á, keyboard input, ‡πÅ‡∏•‡∏∞ events
- **stb_image.h**: Single-header library ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û (PNG, JPG, BMP, etc.)
- **glm**: Math library ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì matrices, vectors, ‡πÅ‡∏•‡∏∞ transformations
- **shader_m.h**: Class ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ shader programs (compile, link, set uniforms)

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 2: Function Declarations ‡πÅ‡∏•‡∏∞ Constants

```cpp
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow *window);

const unsigned int SCR_WIDTH = 800;   // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
const unsigned int SCR_HEIGHT = 600;  // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **framebuffer_size_callback**: Callback function ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
- **processInput**: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö keyboard input
- **SCR_WIDTH/SCR_HEIGHT**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô 800x600 pixels

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 3: loadTexture() Function

```cpp
unsigned int loadTexture(const char* path)
{
    unsigned int textureID;
    glGenTextures(1, &textureID);  // ‡∏™‡∏£‡πâ‡∏≤‡∏á texture ID
    
    int width, height, nrComponents;
    unsigned char *data = stbi_load(path, &width, &height, &nrComponents, 0);
    // ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå
}
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏ó‡∏µ‡∏•‡∏∞‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô:**

1. **glGenTextures()**: ‡∏™‡∏£‡πâ‡∏≤‡∏á texture object ‡πÅ‡∏•‡∏∞‡πÑ‡∏î‡πâ texture ID
2. **stbi_load()**: ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡∏∞‡πÑ‡∏î‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• pixel data
   - `path`: path ‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û
   - `width, height`: ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û
   - `nrComponents`: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô channels (1=grayscale, 3=RGB, 4=RGBA)

3. **Format Detection**:
```cpp
if (nrComponents == 1)
    format = GL_RED;      // Grayscale
else if (nrComponents == 3)
    format = GL_RGB;      // RGB (‡πÑ‡∏°‡πà‡∏°‡∏µ alpha)
else if (nrComponents == 4)
    format = GL_RGBA;     // RGBA (‡∏°‡∏µ alpha channel)
```

4. **Upload to GPU**:
```cpp
glBindTexture(GL_TEXTURE_2D, textureID);
glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
```
- **glBindTexture()**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î texture ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
- **glTexImage2D()**: ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• pixel ‡πÑ‡∏õ‡∏¢‡∏±‡∏á GPU

5. **Generate Mipmaps**:
```cpp
glGenerateMipmap(GL_TEXTURE_2D);
```
‡∏™‡∏£‡πâ‡∏≤‡∏á mipmaps ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö texture filtering ‡πÄ‡∏°‡∏∑‡πà‡∏≠ texture ‡∏ñ‡∏π‡∏Å scale

6. **Texture Parameters**:
```cpp
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```
- **GL_TEXTURE_WRAP_S/T**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏≤‡∏£ wrap texture (GL_REPEAT = ‡∏ã‡πâ‡∏≥ texture)
- **GL_TEXTURE_MIN_FILTER**: Filtering ‡πÄ‡∏°‡∏∑‡πà‡∏≠ texture ‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á (‡πÉ‡∏ä‡πâ mipmap)
- **GL_TEXTURE_MAG_FILTER**: Filtering ‡πÄ‡∏°‡∏∑‡πà‡∏≠ texture ‡πÉ‡∏´‡∏ç‡πà‡∏Ç‡∏∂‡πâ‡∏ô (‡πÉ‡∏ä‡πâ linear)

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 4: main() Function - Initialization

**GLFW Initialization:**
```cpp
glfwInit();
glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
```
- **glfwInit()**: ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô GLFW library
- **glfwWindowHint()**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î OpenGL version ‡πÄ‡∏õ‡πá‡∏ô 3.3 ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ Core Profile

**macOS Compatibility:**
```cpp
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif
```
‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö macOS ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î forward compatibility

**Window Creation:**
```cpp
GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "Bomber-Style Top-Down Map", NULL, NULL);
glfwMakeContextCurrent(window);
glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
```
- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏Ç‡∏ô‡∏≤‡∏î 800x600
- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô current context
- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ callback ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á

**GLAD Initialization:**
```cpp
if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
{
    std::cout << "Failed to initialize GLAD" << std::endl;
    return -1;
}
```
‡πÇ‡∏´‡∏•‡∏î OpenGL function pointers ‡∏ú‡πà‡∏≤‡∏ô GLAD

**OpenGL State Configuration:**
```cpp
glEnable(GL_DEPTH_TEST);
```
‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô depth testing ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏ô‡πÄ‡∏î‡∏≠‡∏£‡πå 3D objects ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (objects ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏à‡∏∞‡∏ö‡∏±‡∏á objects ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏Å‡∏•)

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 5: Shader Setup

```cpp
Shader shader("shaders/tile.vs", "shaders/tile.fs");
```
‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞ compile vertex shader ‡πÅ‡∏•‡∏∞ fragment shader ‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 6: Vertex Data Setup

**Block Geometry:**
```cpp
float blockHeight = 0.2f;  // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô (0.2 units)
float blockSize = 1.0f;    // ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å (1.0 unit)
```

**Vertex Array:**
```cpp
float vertices[] = {
    // positions (x, y, z)    // texture coords (u, v)
    // Top face
     0.5f,  blockHeight,  0.5f,   1.0f, 1.0f,  // Top-right
     0.5f,  blockHeight, -0.5f,   1.0f, 0.0f,  // Bottom-right
    -0.5f,  blockHeight, -0.5f,   0.0f, 0.0f,  // Bottom-left
    -0.5f,  blockHeight,  0.5f,   0.0f, 1.0f,  // Top-left
    // ... (faces ‡∏≠‡∏∑‡πà‡∏ô‡πÜ)
};
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ Vertex Data:**
- ‡πÅ‡∏ï‡πà‡∏•‡∏∞ vertex ‡∏°‡∏µ 5 floats: 3 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö position (x, y, z) ‡πÅ‡∏•‡∏∞ 2 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö texture coordinates (u, v)
- Cube ‡∏°‡∏µ 6 faces: Top, Bottom, Front, Back, Right, Left
- ‡πÅ‡∏ï‡πà‡∏•‡∏∞ face ‡∏°‡∏µ 4 vertices (quad) ‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ß‡∏≤‡∏î‡πÄ‡∏õ‡πá‡∏ô 2 triangles

**Index Array:**
```cpp
unsigned int indices[] = {
    // Top face (2 triangles)
    0, 1, 2,  2, 3, 0,  // Triangle 1: (0,1,2), Triangle 2: (2,3,0)
    // Bottom face
    4, 5, 6,  6, 7, 4,
    // ... (faces ‡∏≠‡∏∑‡πà‡∏ô‡πÜ)
};
```
- ‡πÉ‡∏ä‡πâ indices ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô vertices ‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô
- ‡πÅ‡∏ï‡πà‡∏•‡∏∞ face ‡πÉ‡∏ä‡πâ 6 indices (2 triangles √ó 3 vertices)
- ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î 36 indices (6 faces √ó 6 indices)

**VAO/VBO/EBO Setup:**
```cpp
unsigned int VBO, VAO, EBO;
glGenVertexArrays(1, &VAO);  // ‡∏™‡∏£‡πâ‡∏≤‡∏á Vertex Array Object
glGenBuffers(1, &VBO);       // ‡∏™‡∏£‡πâ‡∏≤‡∏á Vertex Buffer Object
glGenBuffers(1, &EBO);       // ‡∏™‡∏£‡πâ‡∏≤‡∏á Element Buffer Object
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **VAO (Vertex Array Object)**: ‡πÄ‡∏Å‡πá‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ vertex attributes ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
- **VBO (Vertex Buffer Object)**: ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• vertex (positions + texture coords)
- **EBO (Element Buffer Object)**: ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• indices

**Upload Data to GPU:**
```cpp
glBindVertexArray(VAO);

glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
```
- **glBufferData()**: ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á GPU
- **GL_STATIC_DRAW**: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∞‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö geometry)

**Vertex Attributes:**
```cpp
// Position attribute (location = 0)
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

// Texture coordinate attribute (location = 1)
glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ glVertexAttribPointer():**
- **0/1**: Attribute location (‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö shader)
- **3/2**: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô components (position=3, texCoord=2)
- **GL_FLOAT**: ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
- **GL_FALSE**: ‡πÑ‡∏°‡πà normalize
- **5 * sizeof(float)**: Stride (‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á vertices)
- **offset**: ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á attribute ‡πÉ‡∏ô vertex

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 7: Texture Loading

```cpp
stbi_set_flip_vertically_on_load(true);  // ‡∏û‡∏•‡∏¥‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏ï‡∏≤‡∏°‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á
std::string texturePath = FileSystem::getPath("assets/floor/ground_tiles_06_color_1k.png");
unsigned int floorTexture = loadTexture(texturePath.c_str());
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **stbi_set_flip_vertically_on_load()**: ‡∏û‡∏•‡∏¥‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÄ‡∏û‡∏£‡∏≤‡∏∞ OpenGL coordinate system ‡∏°‡∏µ origin ‡∏ó‡∏µ‡πà‡∏°‡∏∏‡∏°‡∏•‡πà‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢ ‡πÅ‡∏ï‡πà‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏°‡∏µ‡∏ó‡∏µ‡πà‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏ã‡πâ‡∏≤‡∏¢
- **FileSystem::getPath()**: ‡∏´‡∏≤ path ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á build directory ‡πÅ‡∏•‡∏∞ source directory)
- **loadTexture()**: ‡πÇ‡∏´‡∏•‡∏î texture ‡πÅ‡∏•‡∏∞‡πÑ‡∏î‡πâ texture ID

```cpp
unsigned int borderTexture = loadTexture("assets/Unbreakable_Block/tudor_wall_01_basecolor_1k.png");
```
‡πÇ‡∏´‡∏•‡∏î texture ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡∏≠‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà

**Set Shader Uniform:**
```cpp
shader.use();
shader.setInt("texture1", 0);
```
- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î texture unit 0 ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö uniform "texture1" ‡πÉ‡∏ô shader

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 8: Map Configuration

```cpp
const int MAP_SIZE = 15;           // ‡∏Ç‡∏ô‡∏≤‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà 15x15 tiles
const float TILE_SIZE = 1.0f;      // ‡∏Ç‡∏ô‡∏≤‡∏î‡πÅ‡∏ï‡πà‡∏•‡∏∞ tile (1.0 unit)
const float MAP_OFFSET = -(MAP_SIZE - 1) * TILE_SIZE / 2.0f;  // ‡∏à‡∏±‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ MAP_OFFSET:**
- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ó‡∏µ‡πà origin (0, 0, 0)
- ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 15 tiles: offset = -(15-1) * 1.0 / 2.0 = -7.0
- ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô tiles ‡∏à‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà x = -7, -6, ..., 0, ..., 6, 7

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 9: Render Loop

```cpp
while (!glfwWindowShouldClose(window))
{
    // ... rendering code ...
}
```
Loop ‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏∞‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á

**Input Processing:**
```cpp
processInput(window);
```
‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö keyboard input (‡πÄ‡∏ä‡πà‡∏ô ESC ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î‡πÄ‡∏Å‡∏°)

**Clear Screen:**
```cpp
glClearColor(0.1f, 0.1f, 0.15f, 1.0f);  // ‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á (R, G, B, Alpha)
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```
- **glClearColor()**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á (‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏Ç‡πâ‡∏°)
- **glClear()**: ‡∏•‡πâ‡∏≤‡∏á color buffer ‡πÅ‡∏•‡∏∞ depth buffer

**Activate Shader:**
```cpp
shader.use();
```
‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô shader program

**Projection Matrix:**
```cpp
float aspect = static_cast<float>(SCR_WIDTH) / static_cast<float>(SCR_HEIGHT);
glm::mat4 projection = glm::perspective(glm::radians(45.0f), aspect, 0.1f, 200.0f);
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **aspect**: ‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏™‡πà‡∏ß‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á/‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á (800/600 = 1.333)
- **glm::perspective()**: ‡∏™‡∏£‡πâ‡∏≤‡∏á perspective projection matrix
  - **45.0f**: Field of View (FOV) ‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏á‡∏®‡∏≤
  - **aspect**: Aspect ratio
  - **0.1f**: Near plane (‡∏£‡∏∞‡∏¢‡∏∞‡πÉ‡∏Å‡∏•‡πâ‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏´‡πá‡∏ô)
  - **200.0f**: Far plane (‡∏£‡∏∞‡∏¢‡∏∞‡πÑ‡∏Å‡∏•‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏´‡πá‡∏ô)

**View Matrix (Camera):**
```cpp
glm::vec3 cameraPos(0.0f, MAP_SIZE * 0.9f, MAP_SIZE * 1.1f);
glm::vec3 cameraTarget(0.0f, 0.0f, 0.0f);
glm::vec3 cameraUp(0.0f, 1.0f, 0.0f);
glm::mat4 view = glm::lookAt(cameraPos, cameraTarget, cameraUp);
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **cameraPos**: ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á (0, 13.5, 16.5) - ‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡πÅ‡∏•‡∏∞‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á
- **cameraTarget**: ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏°‡∏≠‡∏á (0, 0, 0) - ‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
- **cameraUp**: ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô (0, 1, 0) - ‡πÅ‡∏Å‡∏ô Y
- **glm::lookAt()**: ‡∏™‡∏£‡πâ‡∏≤‡∏á view matrix ‡∏à‡∏≤‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á, ‡∏à‡∏∏‡∏î‡∏°‡∏≠‡∏á, ‡πÅ‡∏•‡∏∞‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô

**Set Shader Uniforms:**
```cpp
shader.setMat4("projection", projection);
shader.setMat4("view", view);
```
‡∏™‡πà‡∏á matrices ‡πÑ‡∏õ‡∏¢‡∏±‡∏á shader

**Rendering Floor Tiles:**
```cpp
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, floorTexture);
glBindVertexArray(VAO);

for (int x = 0; x < MAP_SIZE; x++)
{
    for (int z = 0; z < MAP_SIZE; z++)
    {
        float tileX = MAP_OFFSET + x * TILE_SIZE;
        float tileZ = MAP_OFFSET + z * TILE_SIZE;
        
        glm::mat4 model = glm::mat4(1.0f);
        model = glm::translate(model, glm::vec3(tileX, 0.0f, tileZ));
        shader.setMat4("model", model);
        
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
    }
}
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏ó‡∏µ‡∏•‡∏∞‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô:**

1. **Bind Texture**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î texture ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ (floorTexture)
2. **Bind VAO**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î vertex array ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ
3. **Nested Loop**: Loop ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà (15√ó15 = 225 tiles)
4. **Calculate Position**: ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ tile
   - `tileX = -7.0 + x * 1.0` (x = 0..14)
   - `tileZ = -7.0 + z * 1.0` (z = 0..14)
5. **Model Matrix**: ‡∏™‡∏£‡πâ‡∏≤‡∏á transformation matrix
   - `glm::mat4(1.0f)`: Identity matrix
   - `glm::translate()`: ‡∏¢‡πâ‡∏≤‡∏¢‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà (tileX, 0, tileZ)
6. **Set Uniform**: ‡∏™‡πà‡∏á model matrix ‡πÑ‡∏õ‡∏¢‡∏±‡∏á shader
7. **Draw**: ‡∏ß‡∏≤‡∏î cube ‡∏î‡πâ‡∏ß‡∏¢ `glDrawElements()`
   - **GL_TRIANGLES**: ‡∏ß‡∏≤‡∏î‡πÄ‡∏õ‡πá‡∏ô triangles
   - **36**: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô indices (6 faces √ó 6 indices)

**Rendering Border Blocks:**
```cpp
glBindTexture(GL_TEXTURE_2D, borderTexture);
const float fullBlockHeight = 1.0f;
const float borderScaleY = fullBlockHeight / blockHeight;  // 5.0 (1.0 / 0.2)

for (int x = 0; x < MAP_SIZE; x++)
{
    for (int z = 0; z < MAP_SIZE; z++)
    {
        bool isBorder = (x == 0 || x == MAP_SIZE - 1 || z == 0 || z == MAP_SIZE - 1);
        if (!isBorder)
            continue;  // ‡∏Ç‡πâ‡∏≤‡∏° tiles ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Ç‡∏≠‡∏ö
        
        float tileX = MAP_OFFSET + x * TILE_SIZE;
        float tileZ = MAP_OFFSET + z * TILE_SIZE;
        
        glm::mat4 model = glm::mat4(1.0f);
        model = glm::translate(model, glm::vec3(tileX, blockHeight, tileZ));
        model = glm::scale(model, glm::vec3(1.0f, borderScaleY, 1.0f));
        shader.setMat4("model", model);
        
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
    }
}
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **isBorder**: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡πÅ‡∏ñ‡∏ß‡πÅ‡∏£‡∏Å/‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÅ‡∏£‡∏Å/‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢)
- **Translate**: ‡∏¢‡πâ‡∏≤‡∏¢‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏õ‡∏ó‡∏µ‡πà `blockHeight` (0.2) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á‡∏ö‡∏ô‡∏û‡∏∑‡πâ‡∏ô
- **Scale**: Scale ‡πÉ‡∏ô‡πÅ‡∏ô‡∏ß Y ‡∏î‡πâ‡∏ß‡∏¢ `borderScaleY` (5.0) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô 1.0 unit
- **Result**: ‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Ç‡∏≠‡∏ö‡∏à‡∏∞‡∏™‡∏π‡∏á 1.0 unit ‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏π‡∏á 0.2 unit

**Buffer Swap:**
```cpp
glfwSwapBuffers(window);  // ‡∏™‡∏•‡∏±‡∏ö front ‡πÅ‡∏•‡∏∞ back buffer (double buffering)
glfwPollEvents();         // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö events (keyboard, mouse, window)
```
- **Double Buffering**: ‡∏ß‡∏≤‡∏î‡∏ó‡∏µ‡πà back buffer ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô flickering
- **Poll Events**: ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï input ‡πÅ‡∏•‡∏∞ window events

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 10: Cleanup

```cpp
glDeleteVertexArrays(1, &VAO);
glDeleteBuffers(1, &VBO);
glDeleteBuffers(1, &EBO);
glfwTerminate();
return 0;
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **glDeleteVertexArrays()**: ‡∏•‡∏ö VAO
- **glDeleteBuffers()**: ‡∏•‡∏ö VBO ‡πÅ‡∏•‡∏∞ EBO
- **glfwTerminate()**: ‡∏õ‡∏¥‡∏î GLFW ‡πÅ‡∏•‡∏∞‡∏•‡πâ‡∏≤‡∏á resources ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 11: Helper Functions

**processInput():**
```cpp
void processInput(GLFWwindow *window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **glfwGetKey()**: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏õ‡∏∏‡πà‡∏°‡∏ñ‡∏π‡∏Å‡∏Å‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
- **GLFW_KEY_ESCAPE**: ‡∏õ‡∏∏‡πà‡∏° ESC
- **GLFW_PRESS**: ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏î‡∏≠‡∏¢‡∏π‡πà
- **glfwSetWindowShouldClose()**: ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ render loop ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô

**framebuffer_size_callback():**
```cpp
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0, 0, width, height);
}
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- ‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
- **glViewport()**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà OpenGL ‡∏à‡∏∞‡∏ß‡∏≤‡∏î (0, 0 ‡∏ñ‡∏∂‡∏á width, height)
- ‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ö‡∏¥‡∏î‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ß‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á

### üé® Shader Files

#### tile.vs (Vertex Shader)

```glsl
#version 330 core
layout (location = 0) in vec3 aPos;        // ‡∏£‡∏±‡∏ö position ‡∏à‡∏≤‡∏Å CPU
layout (location = 1) in vec2 aTexCoord;   // ‡∏£‡∏±‡∏ö texture coordinates ‡∏à‡∏≤‡∏Å CPU

out vec2 TexCoord;  // ‡∏™‡πà‡∏á texture coordinates ‡πÑ‡∏õ‡∏¢‡∏±‡∏á fragment shader

uniform mat4 model;       // Model matrix (transform object)
uniform mat4 view;        // View matrix (camera)
uniform mat4 projection;  // Projection matrix (perspective)

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏ó‡∏µ‡∏•‡∏∞‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î:**

1. **#version 330 core**: ‡πÉ‡∏ä‡πâ GLSL version 3.30 core profile
2. **layout (location = 0) in vec3 aPos**: 
   - ‡∏£‡∏±‡∏ö vertex position (3 floats: x, y, z)
   - location = 0 ‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö `glVertexAttribPointer(0, ...)`
3. **layout (location = 1) in vec2 aTexCoord**: 
   - ‡∏£‡∏±‡∏ö texture coordinates (2 floats: u, v)
   - location = 1 ‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö `glVertexAttribPointer(1, ...)`
4. **out vec2 TexCoord**: ‡∏™‡πà‡∏á texture coordinates ‡πÑ‡∏õ‡∏¢‡∏±‡∏á fragment shader
5. **uniform mat4**: ‡∏£‡∏±‡∏ö matrices ‡∏à‡∏≤‡∏Å CPU (‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á vertices)
6. **MVP Transformation**: 
   - `projection √ó view √ó model √ó position`
   - Transform ‡∏à‡∏≤‡∏Å local space ‚Üí world space ‚Üí view space ‚Üí clip space
7. **gl_Position**: Output position ‡πÉ‡∏ô clip space (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô vec4)
8. **TexCoord = aTexCoord**: ‡∏™‡πà‡∏á texture coordinates ‡∏ï‡πà‡∏≠‡πÑ‡∏õ

**MVP Transformation Pipeline:**
- **Model Matrix**: Transform ‡∏à‡∏≤‡∏Å local space (object) ‚Üí world space
- **View Matrix**: Transform ‡∏à‡∏≤‡∏Å world space ‚Üí view space (camera space)
- **Projection Matrix**: Transform ‡∏à‡∏≤‡∏Å view space ‚Üí clip space (perspective)

#### tile.fs (Fragment Shader)

```glsl
#version 330 core
out vec4 FragColor;           // ‡∏™‡∏µ output ‡∏Ç‡∏≠‡∏á pixel

in vec2 TexCoord;             // ‡∏£‡∏±‡∏ö texture coordinates ‡∏à‡∏≤‡∏Å vertex shader

uniform sampler2D texture1;   // Texture sampler

void main()
{
    FragColor = texture(texture1, TexCoord);
}
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏ó‡∏µ‡∏•‡∏∞‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î:**

1. **#version 330 core**: ‡πÉ‡∏ä‡πâ GLSL version 3.30 core profile
2. **out vec4 FragColor**: ‡∏™‡∏µ output ‡∏Ç‡∏≠‡∏á pixel (R, G, B, Alpha)
3. **in vec2 TexCoord**: ‡∏£‡∏±‡∏ö texture coordinates ‡∏à‡∏≤‡∏Å vertex shader (interpolated)
4. **uniform sampler2D texture1**: Texture sampler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡πà‡∏≤‡∏ô‡∏™‡∏µ‡∏à‡∏≤‡∏Å texture
5. **texture()**: Function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡πà‡∏≤‡∏ô‡∏™‡∏µ‡∏à‡∏≤‡∏Å texture
   - `texture1`: Texture sampler
   - `TexCoord`: Texture coordinates (u, v) ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏≠‡πà‡∏≤‡∏ô
6. **FragColor**: ‡∏™‡πà‡∏á‡∏™‡∏µ‡πÑ‡∏õ‡∏¢‡∏±‡∏á framebuffer

**Fragment Shader Process:**
- Vertex shader ‡∏™‡πà‡∏á texture coordinates ‡πÑ‡∏õ‡∏¢‡∏±‡∏á fragment shader
- GPU ‡∏à‡∏∞ interpolate texture coordinates ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ pixel
- Fragment shader ‡∏≠‡πà‡∏≤‡∏ô‡∏™‡∏µ‡∏à‡∏≤‡∏Å texture ‡∏ï‡∏≤‡∏° coordinates
- ‡∏™‡πà‡∏á‡∏™‡∏µ‡πÑ‡∏õ‡∏¢‡∏±‡∏á framebuffer

### üîß CMakeLists.txt - Build Configuration

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 1: Download LearnOpenGL Headers

```cmake
file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/learnopengl)

file(WRITE ${CMAKE_BINARY_DIR}/learnopengl/root_directory.h "...")
file(WRITE ${CMAKE_BINARY_DIR}/root_directory.h "...")

file(DOWNLOAD
  https://raw.githubusercontent.com/JoeyDeVries/LearnOpenGL/master/includes/learnopengl/shader_m.h
  ${CMAKE_BINARY_DIR}/learnopengl/shader_m.h
)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **file(MAKE_DIRECTORY)**: ‡∏™‡∏£‡πâ‡∏≤‡∏á directory ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö headers
- **file(WRITE)**: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå root_directory.h ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î root path
- **file(DOWNLOAD)**: ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î utility headers ‡∏à‡∏≤‡∏Å LearnOpenGL repository
- Headers ‡∏ó‡∏µ‡πà‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î: shader_m.h, filesystem.h, model.h, animation.h, etc.

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 2: Project Setup

```cmake
cmake_minimum_required(VERSION 3.16)
project(PlayableCharacter)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **cmake_minimum_required()**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î CMake version ‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
- **project()**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏∑‡πà‡∏≠‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ
- **set(CMAKE_CXX_STANDARD 17)**: ‡πÉ‡∏ä‡πâ C++17 standard
- **CMAKE_CXX_STANDARD_REQUIRED ON**: ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÉ‡∏ä‡πâ C++17 (‡πÑ‡∏°‡πà fallback)

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 3: Fetch External Libraries

**GLFW:**
```cmake
include(FetchContent)

FetchContent_Declare(
  glfw
  GIT_REPOSITORY https://github.com/glfw/glfw.git
  GIT_TAG        3.3.8
)
FetchContent_MakeAvailable(glfw)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **FetchContent**: CMake module ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î dependencies
- **FetchContent_Declare()**: ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î GLFW version 3.3.8
- **FetchContent_MakeAvailable()**: ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ

**GLM:**
```cmake
FetchContent_Declare(
  glm
  GIT_REPOSITORY https://github.com/g-truc/glm.git
  GIT_TAG        0.9.9.8
)
if(POLICY CMP0169)
  cmake_policy(SET CMP0169 OLD)
endif()
FetchContent_GetProperties(glm)
if(NOT glm_POPULATED)
  FetchContent_Populate(glm)
  if(NOT TARGET glm)
    add_library(glm INTERFACE)
    target_include_directories(glm INTERFACE ${glm_SOURCE_DIR})
  endif()
endif()
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î GLM version 0.9.9.8
- **CMP0169 policy**: ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ policy ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö compatibility
- ‡∏™‡∏£‡πâ‡∏≤‡∏á INTERFACE library ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ target

**STB:**
```cmake
FetchContent_Declare(
  stb
  GIT_REPOSITORY https://github.com/nothings/stb.git
  GIT_TAG        master
)
FetchContent_MakeAvailable(stb)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î STB library (single-header library)
- ‡πÉ‡∏ä‡πâ master branch (latest version)

**Assimp:**
```cmake
FetchContent_Declare(
  assimp
  GIT_REPOSITORY https://github.com/assimp/assimp.git
  GIT_TAG        v5.2.5
)
FetchContent_MakeAvailable(assimp)
if(TARGET assimp)
  target_compile_definitions(assimp PRIVATE -D_CRT_SECURE_NO_WARNINGS)
  if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    target_compile_options(assimp PRIVATE -Wno-error=deprecated-declarations)
  endif()
endif()
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î Assimp version 5.2.5
- **target_compile_definitions()**: ‡πÄ‡∏û‡∏¥‡πà‡∏° compile definitions ‡πÄ‡∏û‡∏∑‡πà‡∏≠ suppress warnings
- **target_compile_options()**: ‡πÄ‡∏û‡∏¥‡πà‡∏° compile options ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö macOS/Clang

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 4: GLAD Setup

```cmake
set(LEARNOPENGL_PATH "${CMAKE_SOURCE_DIR}/../LearnOpenGL")
if(EXISTS "${LEARNOPENGL_PATH}/src/glad.c")
    message(STATUS "Using GLAD from LearnOpenGL")
    set(GLAD_INCLUDE_DIR "${LEARNOPENGL_PATH}/includes")
    set(GLAD_SOURCE_FILE "${LEARNOPENGL_PATH}/src/glad.c")
else()
    message(FATAL_ERROR "GLAD files not found...")
endif()
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ GLAD files ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô LearnOpenGL directory ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ paths ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö GLAD include ‡πÅ‡∏•‡∏∞ source files
- ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á error ‡πÅ‡∏•‡∏∞‡∏´‡∏¢‡∏∏‡∏î build

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 5: Include Directories

```cmake
include_directories(
  ${GLAD_INCLUDE_DIR}
  ${glfw_SOURCE_DIR}/include
  ${glm_SOURCE_DIR}
  ${stb_SOURCE_DIR}
  ${assimp_SOURCE_DIR}/include
  ${CMAKE_SOURCE_DIR}/src
)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- ‡πÄ‡∏û‡∏¥‡πà‡∏° include paths ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö libraries ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
- ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ `#include <glad/glad.h>` ‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏ full path

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 6: Create Executable

```cmake
set(SRC src/main.cpp)
add_executable(PlayableCharacter ${SRC})

target_include_directories(PlayableCharacter PRIVATE
  ${CMAKE_BINARY_DIR}
  ${CMAKE_BINARY_DIR}/learnopengl
)

add_library(glad STATIC ${GLAD_SOURCE_FILE})
target_include_directories(glad PUBLIC ${GLAD_INCLUDE_DIR})

target_link_libraries(PlayableCharacter PRIVATE glfw glad assimp glm)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **add_executable()**: ‡∏™‡∏£‡πâ‡∏≤‡∏á executable ‡∏à‡∏≤‡∏Å main.cpp
- **target_include_directories()**: ‡πÄ‡∏û‡∏¥‡πà‡∏° include paths ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö target
- **add_library()**: ‡∏™‡∏£‡πâ‡∏≤‡∏á static library ‡∏à‡∏≤‡∏Å GLAD source
- **target_link_libraries()**: Link libraries ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö executable

**OpenGL Linking:**
```cmake
if (WIN32)
    target_link_libraries(PlayableCharacter PRIVATE opengl32)
else()
    find_package(OpenGL REQUIRED)
    target_link_libraries(PlayableCharacter PRIVATE OpenGL::GL)
endif()
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- Windows: Link ‡∏Å‡∏±‡∏ö opengl32
- Linux/macOS: ‡πÉ‡∏ä‡πâ find_package ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤ OpenGL ‡πÅ‡∏•‡∏∞ link

#### ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 7: Copy Resources

```cmake
add_custom_command(TARGET PlayableCharacter POST_BUILD
  COMMAND ${CMAKE_COMMAND} -E copy_directory
    ${CMAKE_SOURCE_DIR}/assets $<TARGET_FILE_DIR:PlayableCharacter>/assets
  COMMENT "Copying assets to the target binary directory"
)

add_custom_command(TARGET PlayableCharacter POST_BUILD
  COMMAND ${CMAKE_COMMAND} -E copy_directory
    ${CMAKE_SOURCE_DIR}/shaders $<TARGET_FILE_DIR:PlayableCharacter>/shaders
  COMMENT "Copying shaders to the target binary directory"
)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- **add_custom_command()**: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î command ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏£‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏á build
- **POST_BUILD**: ‡∏£‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å build ‡πÄ‡∏™‡∏£‡πá‡∏à
- **copy_directory**: ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å assets ‡πÅ‡∏•‡∏∞ shaders ‡πÑ‡∏õ‡∏¢‡∏±‡∏á build directory
- **$<TARGET_FILE_DIR:...>**: Path ‡∏Ç‡∏≠‡∏á directory ‡∏ó‡∏µ‡πà‡∏°‡∏µ executable

**Install Resources:**
```cmake
install(DIRECTORY ${CMAKE_SOURCE_DIR}/assets
        DESTINATION .
        USE_SOURCE_PERMISSIONS)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ install assets ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ô `cmake --install`

**Visual Studio Debugger Setup:**
```cmake
set_target_properties(PlayableCharacter PROPERTIES
    VS_DEBUGGER_WORKING_DIRECTORY "${CMAKE_SOURCE_DIR}"
    VS_DEBUGGER_ENVIRONMENT "LOGL_ROOT_PATH=${CMAKE_SOURCE_DIR}"
)
```

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ working directory ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Visual Studio debugger
- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ environment variable ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö FileSystem::getPath()

## üîß ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á

### ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏ô `src/main.cpp`:
```cpp
const int MAP_SIZE = 15;  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (‡πÄ‡∏ä‡πà‡∏ô 20 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 20x20)
```

### ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ö‡∏•‡πá‡∏≠‡∏Å
‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏ô `src/main.cpp`:
```cpp
float blockHeight = 0.2f;  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô
const float fullBlockHeight = 1.0f;  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Ç‡∏≠‡∏ö
```

### ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á
‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏ô `src/main.cpp`:
```cpp
glm::vec3 cameraPos(0.0f, MAP_SIZE * 0.9f, MAP_SIZE * 1.1f);  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡πà‡∏≤‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
glm::vec3 cameraTarget(0.0f, 0.0f, 0.0f);  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏°‡∏≠‡∏á
```

### ‡∏õ‡∏£‡∏±‡∏ö‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á (FOV)
‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏ô `src/main.cpp`:
```cpp
glm::mat4 projection = glm::perspective(glm::radians(45.0f), aspect, 0.1f, 200.0f);
// ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô 45.0f ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏≠‡∏∑‡πà‡∏ô (‡πÄ‡∏ä‡πà‡∏ô 60.0f ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏°‡∏∏‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô)
```

### ‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á
‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏ô `src/main.cpp`:
```cpp
glClearColor(0.1f, 0.1f, 0.15f, 1.0f);  // (R, G, B, Alpha)
```

### ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏ô `src/main.cpp`:
```cpp
const unsigned int SCR_WIDTH = 800;   // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á
const unsigned int SCR_HEIGHT = 600;  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á
```

## üìÑ License

‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ license ‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô:
- GLFW: Zlib/libpng license
- GLM: MIT license
- Assimp: BSD 3-Clause license
- GLAD: Public domain
- STB: Public domain

## üë®‚Äçüíª ‡∏ú‡∏π‡πâ‡∏û‡∏±‡∏í‡∏ô‡∏≤

‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ç‡∏≠‡∏á Game Engine Project

## üôè ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì

- LearnOpenGL ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö tutorial ‡πÅ‡∏•‡∏∞ code examples
- Joey de Vries ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö LearnOpenGL resources
